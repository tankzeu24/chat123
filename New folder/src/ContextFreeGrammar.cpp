#include "ContextFreeGrammar.h"
#include "WordBelongsToLanguageMethodSelector.h"
#include<iostream>
using namespace std;
int ContextFreeGrammar::autoGeneratedVariables = 0;

ContextFreeGrammar::ContextFreeGrammar()
{
}

ContextFreeGrammar::ContextFreeGrammar(const set<Rule>& rules, const Variable & variable)
{
	for   (auto rule : rules)
	{
		this->addRule(rule);
	}

	this->setInitialVariable(variable);
}

ContextFreeGrammar::~ContextFreeGrammar()
{
}

void ContextFreeGrammar::addVariable(const Variable & v)
{
	this->variables.insert(v);
}

void ContextFreeGrammar::addTerminal(const Terminal & t)
{
	this->terminals.insert(t);
}

void ContextFreeGrammar::addRule(const Rule & r)
{
	this->addVariable(r.getLeftSide());

	set<char> newTerminals;

	r.getRightSide().getTerminals(newTerminals);

	for   (char character : newTerminals)
	{
		this->addTerminal(Terminal(character));
	}

	set<string> newVariables;

	r.getRightSide().getVariables(newVariables);

	for   (auto variable : newVariables)
	{
		this->addVariable(variable);
	}

	this->rules.insert(r);
}

void ContextFreeGrammar::setInitialVariable(const Variable & v)
{
	this->addVariable(v);
	this->initialVariable = v;
}

const set<Variable>& ContextFreeGrammar::getVariables() const
{
	return this->variables;
}

const set<Terminal>& ContextFreeGrammar::getTerminals() const
{
	return this->terminals;
}

const set<Terminal>& ContextFreeGrammar::getTerminals(set<Terminal> & terminals) const
{
	for   (auto rule : this->getRules())
	{
		set<char> localTerminals;
		rule.getRightSide().getTerminals(localTerminals);

		for   (auto character : localTerminals)
		{
			terminals.insert(character);
		}
	}
	return terminals;
}

const set<Rule>& ContextFreeGrammar::getRules() const
{
	return this->rules;
}

const Variable ContextFreeGrammar::getInitialVariable() const
{
	return this->initialVariable;
}

const set<Rule>& ContextFreeGrammar::getUnitRules(set<Rule>& result) const
{
	for   (auto rule : this->getRules())
	{
		if (rule.isUnit())
		{
			result.insert(rule);
		}
	}

	return result;
}

WordBelongsToLanguageMethodSelector ContextFreeGrammar::wordBelongsToLanguage(string word) const
{
	return WordBelongsToLanguageMethodSelector(*this, word);
}

const bool ContextFreeGrammar::isChomskyNormal() const
{
	for   (auto rule : this->getRules())
	{
		if (!rule.getRightSide().isChomskyRightSide())
		{
			return false;
		}
	}

	return true;
}

void ContextFreeGrammar::convertToChomskyNormal()
{
	this->epsilonRulesElimination();      //add rules A-aZ,A->Za,A->ZZ where Z-> empty and add if R->Z and z->empty add R->empty
	this->eliminateCyclicUnitRules();      // A->B ,B->C,C->A and C-> somthing;
	this->eliminateUncyclicUnitRules();     // A->B ,B->C,C->A and exists at least 2 which go at something
	this->eliminateMixedRules();
	this->eliminateRulesWithLongRightSide();
}

void ContextFreeGrammar::epsilonRulesElimination()
{
	set<Variable> epsilonSet;
	this->extractEpsilonSet(epsilonSet); //add letters that go epsilon
	this->addRulesWithoutEpsilonVariables(epsilonSet);  // Add rules add rules A-aZ,A->Za,A->ZZ to A->a,A->a,A->Z respectiv
	this->removeRulesWithEmptyRightSide();

	bool initialVariableIsContainedInEpsilonSet = epsilonSet.find(this->initialVariable) != epsilonSet.end();

	if (initialVariableIsContainedInEpsilonSet)
	{
		RightSide rs;
		rs.append(this->initialVariable);
		this->generateVariable(this->initialVariable);
		Rule r(this->initialVariable), w(this->initialVariable, rs);
		this->addRule(r);
		this->addRule(w);
	}
}

void ContextFreeGrammar::eliminateCyclicUnitRules()
{
	set<Rule> newUnitRules;
	set<Rule> oldUnitRules;

	this->getUnitRules(oldUnitRules); //get A->B rules;
	newUnitRules = oldUnitRules;

	auto stronglyConnectedComponents = this->extractStronglyConnectedComponents(newUnitRules);

	for   (auto stronglyConnectedComponent : stronglyConnectedComponents)
	{
		this->unifyAllVariables(stronglyConnectedComponent, newUnitRules);
	}

	set<Rule> newGrammarRules;

	for   (auto rule : this->getRules())
	{
		// remove old unit rules; we will add the new later
		if (!oldUnitRules.count(rule) && !rule.isUseless())
		{
			newGrammarRules.insert(rule);
		}
	}
       //for those that dont need work
	for   (auto rule : newUnitRules)
	{
		if (!rule.isUseless())
		{
			newGrammarRules.insert(rule);
		}
	}

	this->rules = newGrammarRules;
}

void ContextFreeGrammar::eliminateUncyclicUnitRules()
{
	Rule feasibleRule = this->getUnitRuleWithRightSideNotInGraph(this->getRules());
	// Намери всички правило=feasibleRule чиито дясна страна съществува правило с лява страна=дясната
  //и второто правило терминира

	while (feasibleRule.getLeftSide() != Variable("Rule not found"))
	{
	     //after you find a rule and check if the RHS is equal to a terminating rule's RHS
	    // then insert that new rule
	    //
		Variable X = feasibleRule.getLeftSide();
		Variable Y = Variable(feasibleRule.getRightSide().getVariables().begin()->toString());

		set<Rule> rulesThatTerminate = this->getRulesFrom(Y, this->getRules());

		for   (auto ruleThatTerminates : rulesThatTerminate)
		{
		    //Насочи X да сочи към нещо крайно
			auto ruleToAdd = Rule(X, ruleThatTerminates.getRightSide());
			this->rules.insert(ruleToAdd);
		}
         //премахни правилата които не са Unit и дясната им страна е Y
		this->removeUnitRulesThatGoTo(Y);

		feasibleRule = this->getUnitRuleWithRightSideNotInGraph(this->getRules());
	}
}

const Rule ContextFreeGrammar::getUnitRuleWithRightSideNotInGraph(const set<Rule>& unitRules)
{
	for   (auto unitRule : unitRules)
	{
		if (unitRule.isUnit())
		{
			Variable rightSide = Variable(unitRule.getRightSide().getVariables().begin()->toString());

			for   (auto rule : this->getRules())
			{
				if (rightSide == rule.getLeftSide() && !rule.isUnit())
				{
					return unitRule;
				}
			}
		}
	}

	return Rule(Variable("Rule not found"));
}

const set<Rule> ContextFreeGrammar::getRulesFrom(const Variable & v, const set<Rule>& rules)
{
	set<Rule> result;

	for   (auto rule : rules)
	{
		if (v == rule.getLeftSide())
		{
			result.insert(rule);
		}
	}

	return result;
}

void ContextFreeGrammar::removeUnitRulesThatGoTo(const Variable & v)
{
	set<Rule> newRules;

	for   (auto rule : this->getRules())
	{
		if (!(rule.isUnit() &&
			Variable(rule.getRightSide().getVariables().begin()->toString()) == v))
		{
			newRules.insert(rule);
		}
	}

	this->rules = newRules;
}

void ContextFreeGrammar::eliminateMixedRules()
 //За правила от вида A ->u1u2 u1,u2 \belong ALL заменяме всяка буква ui с нова
    //променлива Ui и добавяме  Ui->ui .Example : A->aB => A->XB && X->a where X is new
{
	set<Terminal> alphabet = this->getTerminals();

	map<Terminal, Variable> replacingVariable;

	set<Rule> newRules;

	for   (auto terminal : alphabet)
	{
		Variable generated;
		ContextFreeGrammar::generateVariable(generated);
		replacingVariable[terminal] = generated;
		RightSide rs;
		rs.append(terminal);
		  // X->a
		newRules.insert(Rule(replacingVariable[terminal], rs));
	}

	for   (auto rule : this->getRules())
	{
		if (rule.getRightSide().length() >= 2)
		{
			Rule newRule(rule);
			auto terminalsInRule = rule.getTerminals();

			for   (auto terminalInRule : terminalsInRule)
			{
			       //iterating over a rule like A->Abc we must change b and c and become A->{A}{Auto 1}{AUTO 2}
				newRule.replaceTerminalWithVariableInRightSide(terminalInRule, replacingVariable[terminalInRule]);
			}

			newRules.insert(newRule);
		}

		else
		{
			newRules.insert(rule);
		}
	}

	this->rules = newRules;
}

void ContextFreeGrammar::RemoveRule(const Rule &r)
{
    this->rules.erase(r);
}
void ContextFreeGrammar::eliminateRulesWithLongRightSide()
{
	Rule ruleWithLongRightSide = this->existsRuleWithLongRightSide();

	while (ruleWithLongRightSide.getLeftSide() != Variable("Rule not found"))
	{
		Variable newVariable;
		ContextFreeGrammar::generateVariable(newVariable);

		RightSide rs = ruleWithLongRightSide.extractLastTwoVariables();

		Rule newRule(newVariable, rs);

		this->addRule(newRule);

		Rule maintainOldRule(
			ruleWithLongRightSide.getLeftSide(),
			ruleWithLongRightSide.replaceLastTwoVariablesWith(newVariable));

		this->addRule(maintainOldRule);
         //Since no longer will exist
		this->rules.erase(ruleWithLongRightSide);
		//pretty much do this :
		//cfg << "{A}->{B}{C}{D}";

		//	cfg.eliminateRulesWithLongRightSide();


        //("{A}->{B}{AUTO 0}"));
		//"{AUTO 0}->{C}{D}"));

		ruleWithLongRightSide = this->existsRuleWithLongRightSide();
	}
}

const Rule ContextFreeGrammar::existsRuleWithLongRightSide() const
{
	for   (auto rule : this->getRules())
	{
		if (rule.getRightSide().length() >= 3)
		{
			return rule;
		}
	}

	return Rule(Variable("Rule not found"));
}

const set<set<Variable>> ContextFreeGrammar::extractStronglyConnectedComponents(const set<Rule>& rules) const
{
	/*
		Tarjan's algorithm for strongly connected components
	*/
	set<set<Variable>> result;

	stack<Variable> s;
	int globalIndex = 0;

	map<Variable, int> index;
	map<Variable, int> lowlink;
	map<Variable, bool> onStack;

	auto unitVariables = this->getUnitVariables(rules);

	for   (auto unitVariable : unitVariables)
	{
		if (!index.count(unitVariable))
		{
			this->tarjanStronglyConnected(unitVariable, unitVariables, rules, s, globalIndex, index, lowlink, onStack, result);
		}
	}

	return result;
}

void ContextFreeGrammar::tarjanStronglyConnected(
	const Variable & unitVariable,
	const set<Variable>& unitVariables,
	const set<Rule>& unitRules,
	stack<Variable>& s,
	int & globalIndex,
	map<Variable, int> & index,
	map<Variable, int> & lowlink,
	map<Variable, bool> & onStack,
	set<set<Variable>> & result) const
{
	index[unitVariable] = globalIndex;
	lowlink[unitVariable] = globalIndex;
	globalIndex++;
	s.push(unitVariable);
	onStack[unitVariable] = true;

	for   (auto rule : unitRules)
	{
		if (rule.getLeftSide() == unitVariable)
		{
			auto successor = Variable(rule.getRightSide().getVariables().begin()->toString());

			if (!index.count(successor))
			{
				this->tarjanStronglyConnected(successor, unitVariables, unitRules, s, globalIndex, index, lowlink, onStack, result);
				lowlink[unitVariable] = min(lowlink[unitVariable], lowlink[successor]);
			}

			else if (onStack[successor])
			{
				lowlink[unitVariable] = min(lowlink[unitVariable], index[successor]);
			}
		}
	}

	/*
	if (v.lowlink = v.index) then
	start a new strongly connected component
	repeat
	w := S.pop()
	w.onStack := false
	add w to current strongly connected component
	while (w != v)
	output the current strongly connected component
	end if
	end function
	*/
	if (lowlink[unitVariable] == index[unitVariable])
	{
		set<Variable> newStronglyConnectedComponent;
		newStronglyConnectedComponent.insert(unitVariable);

		Variable w;
		do
		{
			w = s.top();
			s.pop();
			onStack[w] = false;
			newStronglyConnectedComponent.insert(w);
		} while (w != unitVariable);

		result.insert(newStronglyConnectedComponent);
	}
}

const set<Variable> ContextFreeGrammar::getUnitVariables(const set<Rule>& rules) const
{
	set<Variable> result;

	for   (auto rule : rules)
	{
		result.insert(rule.getLeftSide());
		auto variablesFromRightSide = rule.getRightSide().getVariables();
		result.insert(variablesFromRightSide.begin(), variablesFromRightSide.end());
	}

	return result;
}

const Variable ContextFreeGrammar::existsRuleThatGoesToEpsilonSet(const set<Variable>& epsilonSet) const
{
	for   (auto rule : this->getRules())
	{
		bool variableDoesNotBelongToEpsilonSet = epsilonSet.find(rule.getLeftSide()) == epsilonSet.end();
		bool rightSideIsMadeOfEpsilonSet = rule.getRightSide().consistsOfVariablesOfSet(epsilonSet);

		if (variableDoesNotBelongToEpsilonSet && rightSideIsMadeOfEpsilonSet)
		{
			return rule.getLeftSide();
		}
	}

	return Variable("Rule not found");
}

const Rule & ContextFreeGrammar::existsRuleContainingVariableFromEpsilonSet(const set<Variable>& epsilonSet, Rule & result) const
{
	for   (auto rule : this->getRules())
	{
		for   (auto variable : epsilonSet)
		{
			if (rule.getRightSide().contains(variable))
			{
				RightSide newRightSide;
				rule.getRightSide().withoutVariable(variable, newRightSide);
				result = Rule(rule.getLeftSide(), newRightSide);

				bool isAlreadyContained = this->getRules().find(result) != this->getRules().end();

				if (!isAlreadyContained)
				{
					return result;
				}
			}
		}
	}

	result = Rule("Rule not found");
	return result;
}

void ContextFreeGrammar::unifyAllVariables(const set<Variable>& variables, set<Rule>& rules)
{
	Variable referenceVariable = *variables.begin();

	for   (auto variable : variables)
	{
		this->replaceVariableWith(variable, referenceVariable, rules);
	}
}

void ContextFreeGrammar::replaceVariableWith(const Variable & v, const Variable & replacing, set<Rule> & rules)
{
	set<Rule> result;
	for   (auto rule : rules)
	{
		if (rule.getLeftSide() == v)
		{
			rule.setLeftSide(replacing);
		}

		if (rule.getRightSide().equals(v))
		{
			rule.replaceRightSide(replacing);
		}
		result.insert(rule);
	}

	rules = result;
}

const set<Variable>& ContextFreeGrammar::extractEpsilonSet(set<Variable>& epsilonSet) const
{
	Variable variableToBeAdded = this->existsRuleThatGoesToEpsilonSet(epsilonSet);

	while (variableToBeAdded != Variable("Rule not found"))
	{
		epsilonSet.insert(variableToBeAdded);
		variableToBeAdded = this->existsRuleThatGoesToEpsilonSet(epsilonSet);
	}

	return epsilonSet;
}

void ContextFreeGrammar::addRulesWithoutEpsilonVariables(set<Variable>& epsilonSet)
{
	Rule resultRule("Initial");
	this->existsRuleContainingVariableFromEpsilonSet(epsilonSet, resultRule);

	while (resultRule.getLeftSide() != Rule("Rule not found").getLeftSide())
	{
		this->addRule(resultRule);
		this->existsRuleContainingVariableFromEpsilonSet(epsilonSet, resultRule);
	}
}

void ContextFreeGrammar::removeRulesWithEmptyRightSide()
{
	set<Rule> newRules;

	for   (auto rule : this->getRules())
	{
		if (!rule.getRightSide().empty())
		{
			newRules.insert(rule);
		}
	}

	this->rules = newRules;
}
namespace patch
{
    template < typename T > std::string to_string( const T& n )
    {
        std::ostringstream stm ;
        stm << n ;
        return stm.str() ;
    }
}

const Variable & ContextFreeGrammar::generateVariable(Variable & v) const
{
	v = Variable("AUTO " + patch::to_string(ContextFreeGrammar::autoGeneratedVariables));

	autoGeneratedVariables++;
	return v;
}

void ContextFreeGrammar::createAsUnionOf(const ContextFreeGrammar & cfg1, const ContextFreeGrammar & cfg2)
{
	for   (auto rule : cfg1.getRules())
	{
		this->addRule(rule);
	}

	for   (auto rule : cfg2.getRules())
	{
		this->addRule(rule);
	}

	Variable newInitial;
	ContextFreeGrammar::generateVariable(newInitial);

	RightSide rightSideFirstNewRule;
	rightSideFirstNewRule.append(cfg1.getInitialVariable());
	Rule ruleToFirstGrammarInitialVariable(newInitial, rightSideFirstNewRule);

	RightSide rightSideSecondNewRule;
	rightSideSecondNewRule.append(cfg2.getInitialVariable());
	Rule ruleToSecondGrammarInitialVariable(newInitial, rightSideSecondNewRule);

	this->addRule(ruleToFirstGrammarInitialVariable);
	this->addRule(ruleToSecondGrammarInitialVariable);

	this->setInitialVariable(newInitial);
}

void ContextFreeGrammar::createAsConcatenationOf(const ContextFreeGrammar & cfg1, const ContextFreeGrammar & cfg2)
{
	for   (auto rule : cfg1.getRules())
	{
		this->addRule(rule);
	}

	for   (auto rule : cfg2.getRules())
	{
		this->addRule(rule);
	}

	Variable newInitial;
	ContextFreeGrammar::generateVariable(newInitial);

	RightSide rs;
	rs.append(cfg1.getInitialVariable());
	rs.append(cfg2.getInitialVariable());
	Rule newRule(newInitial, rs);

	this->addRule(newRule);
}

void ContextFreeGrammar::createAsIterationOf(const ContextFreeGrammar & cfg)
{
	for   (auto rule : cfg.getRules())
	{
		if (!(rule.getLeftSide() == cfg.getInitialVariable() && rule.getRightSide().empty()))
		{
			this->addRule(rule);
		}
	}

	Variable newInitial;
	ContextFreeGrammar::generateVariable(newInitial);

	this->setInitialVariable(newInitial);
	this->addRule(Rule(newInitial));

	RightSide rs;
	rs.append(cfg.getInitialVariable());
	this->addRule(Rule(newInitial, rs));

	rs.append(cfg.getInitialVariable());
	this->addRule(Rule(newInitial, rs));
}

const bool ContextFreeGrammar::languageIsEmpty() const
{
	set<Variable> Marked;

	for   (auto rule : this->getRules())
	{
		set<char> terminals;
		rule.getRightSide().getTerminals(terminals);

		for   (auto character : terminals)
		{
			Marked.insert(Variable(patch::to_string(character)));
		}
	}

	Variable toAdd = this->existsRuleThatGoesToEpsilonSet(Marked);

	while (toAdd != Variable("Rule not found"))
	{
		Marked.insert(toAdd);
		toAdd = this->existsRuleThatGoesToEpsilonSet(Marked);
	}

	return Marked.find(this->initialVariable) == Marked.end();
}

void ContextFreeGrammar::printRules()
{   int pos=1;
    for( auto rule : this->getRules())
    {
       Variable left = rule.getLeftSide();
       RightSide right=rule.getRightSide();
       cout<<pos<<". "<<left.getLabel()<<" -> "<<right.toString()<<endl;
       pos++;

    }
}


const bool ContextFreeGrammar::languageIsFinite() const
{
	ContextFreeGrammar cfg(*this);

	if (!cfg.isChomskyNormal())
	{
		cfg.convertToChomskyNormal();
	}

	unsigned n = cfg.getRules().size();

	set<Terminal> alphabet;
	this->getTerminals(alphabet);

	vector<string> words;
	Terminal::generateWords(n, 2 * n, alphabet, words);

	for   (auto word : words)
	{
		if (this->wordBelongsToLanguage(word).usingPushdownAutomaton())
		{
			// language is infinite
			return false;
		}
	}

	return true;
}

ContextFreeGrammar & operator<<(ContextFreeGrammar & cfg, string toRead)
{
	// :dicates we are setting an iniitial variable
	if (toRead[0] == 'I')
	{
		string parsedNameOfVariable = Variable::parseLabel(toRead.substr(1, toRead.length() - 1));
		cfg.setInitialVariable(Variable(parsedNameOfVariable));
		return cfg;
	}

	// else we are dealing with a string in the format
	// {VariableName}->RightSide

	Rule newRule = Rule::parseLabel(toRead);

	cfg.addRule(newRule);

	return cfg;
}
